uniform vec2 screen;
uniform vec3 pos;
uniform vec3 dir;
uniform vec3 up;

vec3 normal = vec3(0,0,0);
vec3 lastPos = vec3(0,0,0);

vec2 offset(vec2 p) {
    p.x -= screen.x/2.0;
    p.y -= screen.y/2.0;
    return p;
}

float DistanceEstimator (vec3 pos) {
	vec3 z = pos;
	float dr = 1.0;
	float r = 0.0;
	float Power = 8.0;
	int Iterations = 10;
	float Bailout = 4.0;
	for (int i = 0; i < Iterations ; i++) {
		r = length(z);
		if (r>Bailout) break;
		
		// convert to polar coordinates
		float theta = acos(z.z/r);
		float phi = atan(z.y,z.x);
		dr =  pow( r, Power-1.0)*Power*dr + 1.0;
		
		// scale and rotate the point
		float zr = pow( r,Power);
		theta = theta*Power;
		phi = phi*Power;
		
		// convert back to cartesian coordinates
		z = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));
		z+=pos;
	}
	return 0.5*log(r)*r/dr;
}

float trace(vec3 from, vec3 direction) {
	float epsilon = .001;
	float totalDistance = 0.0;
	int steps = 0;
	int maxRaySteps = 75;
	for (;steps < maxRaySteps; ++steps) {
		vec3 p = from + totalDistance * direction;
		float dist = DistanceEstimator(p);
		totalDistance += dist;
		if (dist < epsilon) {
			lastPos = p;
		break; }
	}
	return 1.0 - float(steps)/float(maxRaySteps);
}

void main(void) {

	vec3 lightDir = normalize(vec3(1,1,1));
	vec3 lightDir2 = normalize(vec3(1,1,-1));

	vec3 right = cross(dir,up);
	vec3 realPos = pos;


	vec2 screenPos = offset(gl_FragCoord.xy);
	float epsilon = .005;
	
	screenPos.x /= screen.x/4.0;
	screenPos.y /= screen.x/4.0;


	//transform domain

	float c = .125;

	vec3 x =  right * c * screenPos.x;
	vec3 y =  up * c * screenPos.y;
	vec3 realDir = normalize(dir+x+y);



	realPos += right * screenPos.x;
	realPos += up * screenPos.y;
	float t = trace(realPos,realDir);
	vec3 xx = vec3(1,0,0);
	vec3 yy = vec3(0,1,0);
	vec3 zz = vec3(0,0,1);

	vec3 normal = normalize(vec3(
		DistanceEstimator(lastPos+epsilon*xx),
		DistanceEstimator(lastPos+epsilon*yy),
		DistanceEstimator(lastPos+epsilon*zz)
	)); 
	float l = 0.5;
	if (t > .00001) {


		gl_FragColor.r = 3. * mod (t , 0.3);
		gl_FragColor.g = 20. * mod (t , 0.05);
		gl_FragColor.b = 1.42857  * mod (t , 0.7);
		gl_FragColor.a = 1.0;
		
		gl_FragColor = gl_FragColor*0.2;

		if (dot(normal,lightDir) > 0.0)
			gl_FragColor = gl_FragColor + vec4(l,l,l,1.0) * pow(dot(normal,lightDir),7);
	}
	else
		gl_FragColor = vec4(0,0,0, 1.0);
}
