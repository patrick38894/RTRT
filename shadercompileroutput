uniform vec2 screen;
uniform vec3 viewDir;
uniform vec3 up;
uniform int maxRaySteps;
uniform float epsilon;
uniform float time;
vec3 intersect;
vec2 offset(vec2 p) {
	return p - 0.5*screen;
}
float trace(vec3 from, vec3 dir) {
	float totalDistance = 0.0;
	int steps = 0;
	for (;steps < maxRaySteps; ++steps) {
		vec3 p = from + totalDistance * dir;
		float dist = DE(p);
		totalDistance += dist;
		if (dist < epsilon) {
			intersect = p;
			break;
		}
	}
	return 1.0 - float(steps)/float(maxRaySteps);
}
float DE(vec3 p) {return length(p) - 1.0; }
void main(void) {

int numlights = 1;
vec3 lightPositions[numlights];
float lightIntensities [numlights];
float lightDiffuses[numlights];
lightPositions[ 0] = vec3(3.000000,3.000000,3.000000);
lightIntensities[ 0] = 0.500000;
lightDiffuses[ 0] = 9.000000;
vec3 right = cross(dir,up);
vec3 realPos = pos;
vec2 screenPos = offset(gl_FragCoord.xy);
float diffEpsilon = epsilon * 10;
screenPos = screenPos * 4 / screen.x;
float c = .125;
vec3 x = right * c * screenPos.x;
vec3 y = up * c * screenPos.y;
vec3 realDir = normalize(viewDir+x+y);
realPos += right * screenPos.x;
realPos += up * screenPos.y;
float t = trace(realPos,realDir);
vec3 xx = vec3(1,0,0);
vec3 yy = vec3(0,1,0);
vec3 zz = vec3(0,0,1);
vec3 normal = normalize(vec3(
		DE(intersect+diffEpsilon*xx)-DE(intersect),
		DE(intersect+diffEpsilon*yy)-DE(intersect),
		DE(intersect+diffEpsilon*zz)-DE(intersect)));
gl_FragColor = vec4(lightIntensities[0]*pow(dot(normal,normalize(lightPositions[0])),lightDiffuses[0]),0,0,1);
}
