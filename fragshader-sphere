uniform vec2 screen;
uniform vec3 pos;
uniform vec3 dir;
uniform vec3 up;

vec3 normal = vec3(0,0,0);
vec3 lastPos = vec3(0,0,0);

vec2 offset(vec2 p) {
    p.x -= screen.x/2.0;
    p.y -= screen.y/2.0;
    return p;
}

float DistanceEstimator (vec3 p) {
	return length(p) - 0.5;
}

float trace(vec3 from, vec3 direction) {
	float epsilon = .000001;
	float totalDistance = 0.0;
	int steps = 0;
	int maxRaySteps = 50;
	for (;steps < maxRaySteps; ++steps) {
		vec3 p = from + totalDistance * direction;
		float dist = DistanceEstimator(p);
		totalDistance += dist;
		if (dist < epsilon) {
			lastPos = p;
		break; }
	}
	return 1.0 - float(steps)/float(maxRaySteps);
}

void main(void) {

	vec3 lightDir = normalize(vec3(1,1,1));

	vec3 right = cross(dir,up);
	vec3 realPos = pos;
	vec2 screenPos = offset(gl_FragCoord.xy);
	float epsilon = .001;
	
	screenPos.x /= screen.x/4.0;
	screenPos.y /= screen.x/4.0;
	realPos += right * screenPos.x;
	realPos += up * screenPos.y;
	float t = trace(realPos,dir);
	vec3 x = vec3(1,0,0);
	vec3 y = vec3(0,1,0);
	vec3 z = vec3(0,0,1);

	vec3 normal = normalize(vec3(
		DistanceEstimator(lastPos+epsilon*x),
		DistanceEstimator(lastPos+epsilon*y),
		DistanceEstimator(lastPos+epsilon*z)
	)); 
	if (t > .00001) {
		if (dot(normal,lightDir) > 0.0)
			gl_FragColor = vec4(clamp(pow(dot(normal,lightDir),7), 0, 1),clamp(dot(normal,lightDir),0.05,1),clamp(pow(dot(normal,lightDir),9), 0, 1), 1.0);
		else
			gl_FragColor = vec4(0,clamp(dot(normal,lightDir),0.05,1),0.03, 1.0);
	}
	else
		gl_FragColor = vec4(0,0,0, 1.0);
}
